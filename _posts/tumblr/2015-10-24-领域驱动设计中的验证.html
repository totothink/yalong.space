---
layout: post
title: "领域驱动设计中的验证"
date: '2015-10-24T08:44:33+08:00'
tags:
- validation
- ddd
tumblr_url: http://yalong.tumblr.com/post/131780154250/领域驱动设计中的验证
---
<p>验证是一个宽泛的话题，它普遍贯穿了应用程序的各个方面(area)。在实践中实现验证也是困难的，因为它的实现贯穿了应用程序的各个方面，通常每个方面采用不同的方法。一般来说，验证是一种机制，用于确保操作结果保持有效状态。该声明的模糊性不容忽视，因为它说明了验证的几个重要特性。一个特性是上下文(context) - 验证发生在特定的上下文中。上下文至关重要，因为在一个上下文中验证可能并不适合用在另一个上下文中。另一个推论是“认为什么是有效的”的开放性。它可能是很简单的声明，例如“客户名称不能为空”，或者是一个复杂的Cycl断言序列。</p>

<h2>始终有效(Aways Valid)</h2>

<p>在领域驱动设计中，围绕始终有效实体的观点有两个思想流派。Jeffrey Palermo提出始终有效实体是一个谬论。他建议验证逻辑应该与实体解耦，这将推迟调用验证规则的决定(determination)。另一种思想流派被Greg Young和其他人支持，他们认为实体应该始终有效。（我必须承认，我站在始终有效一边，因此我的语言存在偏见）</p>

<p>Palermo对场景的探索无疑是恰当的和典型的，不管怎样，涉及始终有效的解决方案能被实现。他辩称他的例子应该考虑以下几点：</p>

<ul><li>事实上，名字是必须的需要被绑定一个上下文。如果是无效的？</li>
<li>消息应该是表示层的责任</li>
<li>当加载历史数据时，一些性别可能缺失。当加载数据时应用程序应该崩溃？</li>
<li>当加载历史数据时，当用户下一次编辑profile时可能用户需要输入性别。</li>
</ul><p>对于第一点，如果用户profile实体防止被赋予空名字，整个应用程序将崩溃。Palmero的解决方案解耦验证代码，这样可以发生调用一组不同的验证规则。另一种解决方案是为特定场景使用不同模型。事实上，<a href="http://gorodinski.com/blog/2012/04/25/read-models-as-a-tactical-pattern-in-domain-driven-design-ddd/">读模型模式</a>可能是一种适合的方法。第二点讨论的是表现层中的错误消息。用户错误消息肯定是表现层的责任，但始终有效实体并不意味着通过实体抛出的异常中的错误消息应该直接传播到表示层。相反，这被认为是一种反模式和一个潜在的安全威胁。相反，表现层被视为<a href="http://alistair.cockburn.us/Hexagonal+architecture">六边型架构</a>中的一个适配器，应该捕获和解释异常并翻译成一种和UI框架适用的形式。最后，最后的两点讨论了一个有趣的进化问题。假设性别属性被引入用户profile实体。显然，现有用户不会有性别。这是一个现实业务场景，从商业的角度来看用户没有指定性别只是用户没有指定性别。当翻译成代码时，意味着性别类型“不明”。当询问用户特定性别时，这种性别类型可以看作工作流初始的一个标记。对于新用户，表现层能够强制规定性别必须被指定。不需要让实体进入一个无效状态。从DDD角度来看，验证规则可以被视为不变量。聚合根的一个核心责任就是状态改变时对不变量的强制执行。</p>

<p><a href="http://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/">Jimmy Bogard</a>写道：</p>

<pre><code> 如果我们对实体也一样开始寻找command/query分离和操作关闭（closure of operations）而不仅是对我们的服务对象，我们对实体多一点尊重，而不是将它们拖到他们并不真正属于他们的区域。简单地说，如果我们控制方程的操作，在这个世界中为什么我们要允许我们的实体进入无效的状态？如果我们的实体有“IsValid”属性，生活变得太复杂。
</code></pre>

<p>这些简单的语句涵盖了大量信息。首先是“IsValid”特性的想法。调用验证或查询“IsValid”特性的需求需要调用非原子的代码，这可能导致不一致性和更大的潜在人为错误。这是一个差别。</p>

<p>还有，第二个代码案例要求UserProfile类的客户需要关注“IsValid”特性，并且一直要使用它。第一个代码案例避免了这一切－实例化用户profile是一个原子操作。这是利用编程语言构建表达现实世界约束的好例子。Bograd说的下一个重要部分是“不要将它们拖入并不真正属于他们的区域”，将在下一个环节中阐述。如果在一个区域内实体验证似乎不妥，这可能是实体不属于该区域的一种迹象。</p>

<h2>应用程序的层次</h2>

<p>所有复杂的企业应用程序都是由多层组成。从用户的角度来看，层是抽象出来的，它们单独存在，以帮助程序员管理所有的复杂性。不同的层意味着为了信息传播，层与层之间必须翻译。例如：一个典型的企业用例：一个实体被从数据库加载，操作，再被持久化到数据库，然后有关该操作的信息通过表示层（可能是REST适配器）返回给用户。应用层的边界是隐性存在的，参考 <a href="http://blog.ploeh.dk/2011/05/31/AtTheBoundariesApplicationsAreNotObjectOriented.aspx">At the Boundaries, Applications are Not Object-Oriented</a>。实体应该在领域层内，而不应该被拖到其他不相干的地方。在表示层，特定的MVC视图可以要求用户输入姓名和性别。输入名字后，性别仍是不确定，目标实体处于无效状态。始终有效实体不能被绑定到这个视图，事实上，它不应该被绑定到视图。 什么是视图模型。 视图模型是表现层的构建块，领域实体不属于那里。相反，适当的领域层实体应该基于视图模型包含的数据创建。这可以直接或通过服务的DTO完成。</p>

<h2>验证框架</h2>

<p>验证可以使用普通的if-then控制流来实现，但这会成为累赘。程序员给出的答案是验证框架。验证框架很多，包括data annotations，FluentValidation，NHibernate Validators， Enterprise Library Validation Block等。 验证框架有可能被滥用，因为人们认为引入一个框架就能解决应用程序的所有验证的问题。不幸的是，这并不总是可能的。实践中，我发现验证框架最适合用在应用层边界内－例如在表现层中校验用户输入，在持久化层确保数据约束，或者在REST适配器上强制执行以符合Schema。在特定上下文中的每层允许独立的实现验证。但这会有一定程度的重复，这是DRY热衷者不能接受的。这个话题在下一节中讨论。</p>

<p>领域层最好使用老式的异常来执行验证规则以保持精益。这是因为验证框架要求调用应用框架，类似之前说的“IsValid”方法。使用ASP.net MVC开发的表现层为注入验证调用逻辑提供操作处理。以这种方式，验证框架可能被应用到整个应用程序。在纯C#或Java代码中不存在类似的注入点，AOP框架的使用可能添加不必要的复杂性。编程语言“short-coming&quot;可以通过扩展homoiconicity来克服。.net代码契约可以看作是一个验证框架，它扩展了静态验证。</p>

<h2>重复验证逻辑</h2>

<p>有StackOverflow问题询问是否有办法重用验证逻辑。在实践中，通常允许一定程度的重复比争取完全一致性更简单。考虑下面的例子。假设我们有一个客户实体，客户必须有名字。在实体里强制执行这个约束很简单：</p>

<p>实体永远不是孤立的，我们必须考虑它的客户。谁调用构成函数？在使用ASP.NET MVC实现的web应用程序有相应的客户视图模型。该视图是表现层的一部分，设计时考虑了数据绑定。Data annotations可以用来声明验证规则：</p>

<p>这个类和领域实体类非常相似，但有几个重要的不同。它有一个无参数的构造函数，没有保护条款以及数据注释验证属性的名称特性。这个类的这些方面使其适合在表示层使用。而不是试图从实体类携带验证规则，名称需求约束被有效的复制。这确实是重复，但它必须比管理某种验证映射框架要简单的多。</p>

<h2>复杂验证</h2>

<p>实体可以执行一定的不变量，但对于实体本身这些不变量的范围总是有限的。由于实体是精益并且自包含，无法获得外部服务或仓库，它们可能没有获得执行一定验证规则所需要的资源。在这种情况下，应用服务可以充当一个中介的作用，产生执行有效性需要的资源。一些存在的业务规则并不是实体或验证框架的职责。例如，用户名的唯一性约束不能由一个实体验证，因为该实体不应该能访问现有用户的数据库。相反，这个规则可以在应用服务中执行。此外，足够复杂的规则可以使用业务规则引擎，在这种情况下应用服务再一次执行验证。另一个更加宏大的原则是本体工程。Cycl是本体语言。本体工程声称可形式化所有业务规则。</p>

<h2>总结</h2>

<ul><li>实体应该强制自身的一致性并且保持始终有效。如果不强制一致性，那么实体的目的是什么？</li>
<li>如果需要允许一个实体进入无效状态，那么考虑应用程序边界是否在要求不同的对象模型。</li>
<li>验证框架最适合在特定的层使用，而不是所有层。</li>
<li>简单的重复验证逻辑比保持它在应用程序所有层的一致性要好</li>
<li>应用服务可以执行实体不能访问的复杂验证规则</li>
</ul><p>原文网址: <a href="http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/">http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/</a></p>
