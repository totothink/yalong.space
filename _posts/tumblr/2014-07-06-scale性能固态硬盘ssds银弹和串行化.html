---
layout: post
title: Scale性能：固态硬盘（SSDs），银弹和串行化
date: '2014-07-06T21:38:00+08:00'
tags:
- "性能"
tumblr_url: http://yalong.tumblr.com/post/90942580520/scale性能固态硬盘ssds银弹和串行化
---
<div>我们都爱银弹。在过去的几年里，如果我要划分结果， 我看到Rackspace客户使用SSDs， 结果大致上分为两种情况。第一种情况是一个银弹——添加SSDs获得近乎奇迹般的性能改进。第二种情况（最常见）通常子弹被射向错误的目标——结果远远低于预期。</div>
<div></div>
<div>
<div><span>第二种情况下，文件系统，数据存储和处理过程经常变得不稳定。这是令人沮丧的结果，但是，经常在客户试图加快错误事情的时候发生。</span></div>
<div></div>
<div>SSD结果令人失望的一个普遍现象是串行化。<span>尽管大多数服务器有并行处理器（例如：多核，多Socket），并行内存系统（例如：NUMA，多通道内存控制器），并行存储系统（例如： 磁盘分段，NAND），以及多线程软件，但事务必须按照一定顺序发生。因为部分软件和系统被设计成为一步一步处理，先第一步，再第二步，然后第三步。它是串行化的。</span></div>
<div></div>
<div>仅仅因为软件或系统的某些部分是天生并行，不意味这这些部分不会被串行化。<span>有些系统在一部分内有能力接收和处理成千上万的离散请求，不料要等待其他串行化部分。软件开发者和系统架构师使用各种方式进行处理。多层Web架构的构想部分解决了这个问题。最近，数据库分片也有助于解决则个问题。但让系统的一部分并行并不意味着所有部分是并行的。有些事，并行化即使被显性的增强，仍然包含一些串行化元素。</span></div>
<div></div>
<div>这个问题有多久了？ 从最初的并行计算开始，至少可以追溯到19世纪60年代。最近10年，在并行内存系统，分布式数据库和存储系统，多核CPU，GPU等方面有了超常的提升。提升往往随着硬件新的创新引入而发生。因此，SSDs，我们通过新的镜头重新审视相同的基本问题。提升不仅只关注于改善SSD本身，我们的整个存储软件栈的概念正在改变。但是，正如您将看到的，即使我们整个存储栈比现在快上几千倍，串行化依然是个问题。<span>我们总是寻找办法处理这个问题,但我们无法让它消失。</span></div>
<div></div>
<div><strong>并行化和串行化</strong></div>
<div>下表提供了服务器和存储设备的并行化和串行化示例。处理过程中的各个步骤可能支持复杂队列和并行机制。即便如此，对于一些给定的事务和事务组，所需的步骤必须按一定顺序。积累每步需要的时间，一个事务需要更多的时间相当于每秒只能完成更少的事务。</div>
<div></div>
<div><img alt="image" height="18" src="src" width="18"/></div>
<div></div>
<div>一系列步骤提供简化的、小的组件 —— 在本例中，存储组件 —— 一台服务器。 另外还有工作在同一台服务器上的<span>各种各样</span><span>其他组件。某些其他组件（例如：数据库应用），往往被cumulatively-chained到存储。我们能为数据库应用创建类似的步骤序列，在数据库应用利用系统存储时，我们将两个表链接起来。我们可以为框架、</span>Web服务、缓存服务等<span>构造类似的macro-level的模型。一些或全部组件被链接在一起完成事务。</span></div>
<div></div>
<div>如前所述，事务中的每个<span>参与的</span><span>组件都将增加累计基线时间。采用不同的工具集、方法和技能提高每个部分。通常，当性能问题被卡住时，我们认为通过花钱能够很容易办到。我们购买更多的服务器、更多的处理器、更快的磁盘、更快的网络卡和交换机。有时，我们很幸运，这是一个银弹，但当我们不幸运时，看看是什么样子。</span></div>
<div></div>
<div>假设我们构建了下一个杀手级应用。它变得越来越受欢迎，并且超过了负载。按照这个增长速度，在3个月里，我们需要10倍的性能提升。我们怎么做？</div>
<div></div>
<div>我们可以在世界范围内的战略位置放置我们的系统副本，减少网络延迟和对核心系统的需要。我们可以将我们所有的服务器和交换机从1GB/sec升级<span>到10GB/sec。我们可以在系统个各个部分添加SSDs。假设我们的网络处理时间减少70%，存储时间降低99.9%（1000倍的提升）。在我们的应用程序（下面模型）只提升83%。它甚至不是双倍的性能，我们已经做了大量的投资。在这点上你可能会想“我们加快存储，在图上并没有显性的反映。1000倍的存储提升和一大笔网络费用只提升了83%的性能？”</span></div>
<div></div>
<div>答案在图中。10倍的提升整体要求累计执行时间从3.0到0.3。</div>
<div><img src="http://33.media.tumblr.com/c0b9af14a3b21a04e6f4a893055a73e4/tumblr_inline_n8amimGVeA1qcfuzk.jpg"/>
</div>
<div></div>
<div>获得10倍的提升将要求我们所有的环境有巨大的提升。让我们假设网络不能被提升。下图展示了要达到10倍速所需要的变动和由此产生的速度。</div>
<div></div>
<div><img src="http://38.media.tumblr.com/c5a869dde50ceefc17c5244a3b70f8f6/tumblr_inline_n8amjtS5Ah1qcfuzk.jpg"/><p></p>
</div>
<div></div>
<div>注意，我们通过4个主要步骤实现这种广泛的性能增益。首先，我们在Web和Cache层做一个可度量的提升，增加一倍速度。第二，我们在数据库层做同样的事，增加一倍速度。这引起我们3.16倍的整体性能提升。由于还不够，我们做第三步：我们重新设计整个平台，并通过努力改善全部的3个平台，比它们的基准速度提升3倍，这能让我们性能提升4.2倍。</div>
<div></div>
<div>看到10倍速多么难以琢磨？ 假设我们聘请一堆超级巨星帮助我们<span>完成旅程&hellip;</span></div>
<div><span> </span></div>
<div><span>因此，第四，超级巨星带来令人惊奇的新技能、代码、工具和观点。我们访问Web，缓存和数据库层比原始设计要快20倍。我们还做了另一个1000倍提升（使用SSDs）。</span></div>
<div></div>
<div>现在，让我们回归现实。如果我们真的需要这些类型的全面大规模的速度提升，惊人要求的想法将放在我们的开发团队中。让我们通过一个类似的镜头​​评估我们的团队和能力。我们需要10倍的开发者技能？每个人将提高10倍？我们将需要10倍的员工？ 10倍的测试资源？这可不是现实，至少，不是一下子。在正确的时间，投入到正确的地方，是该过程的一个重要组成部分。</div>
<div><span> </span></div>
<div><span>在这一过程中,我们需要保持有条不紊,分析我们的差距,找到最谨慎的方式来填补。根据我的经验,谨慎并不激动人心,但它是工作。</span></div>
<div><span> </span></div>
<div>
<p>当面对一个scaling问题,很多人常常以为他们可以通过添加硬件解决它——神秘的银弹。如果你认为,有一个简单的解决方案,它恰巧有一些SSDs，试试!如果不够充分,准备一个全面的旅程。应用我们所覆盖在您自己的应用程序,你自己的基础设施,和自己的团队。打开思想,您可能为达成您的目标需要全面提升。雇佣超级明星并留意串行化；这是反银弹（anti-silver bullet）。</p>

<div></div>
<div>Gene Amdahl经常被誉为第一个标识和记录这些问题的人。你可以在这里阅读更多信息:<span><a href="http://en.wikipedia.org/wiki/Amdahl">http://en.wikipedia.org/wiki/Amdahl</a> &rsquo;s_law。</span></div>
<div></div>
<div></div>
<div><span>原文地址： http://highscalability.com/blog/2014/6/23/performance-at-scale-ssds-silver-bullets-and-serialization.html</span></div>
</div>
</div>
